/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "dscudarpc.h"

bool_t
xdr_RCadr (XDR *xdrs, RCadr *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCstream (XDR *xdrs, RCstream *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCevent (XDR *xdrs, RCevent *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCipaddr (XDR *xdrs, RCipaddr *objp)
{
	register int32_t *buf;

	 if (!xdr_u_quad_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCsize (XDR *xdrs, RCsize *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCerror (XDR *xdrs, RCerror *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCbuf (XDR *xdrs, RCbuf *objp)
{
	register int32_t *buf;

	 if (!xdr_bytes (xdrs, (char **)&objp->RCbuf_val, (u_int *) &objp->RCbuf_len, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCchannelformat (XDR *xdrs, RCchannelformat *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCpid (XDR *xdrs, RCpid *objp)
{
	register int32_t *buf;

	 if (!xdr_u_long (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCchanneldesc_t (XDR *xdrs, RCchanneldesc_t *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->w);
			IXDR_PUT_LONG(buf, objp->x);
			IXDR_PUT_LONG(buf, objp->y);
			IXDR_PUT_LONG(buf, objp->z);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
		} else {
			objp->w = IXDR_GET_LONG(buf);
			objp->x = IXDR_GET_LONG(buf);
			objp->y = IXDR_GET_LONG(buf);
			objp->z = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_RCchannelformat (xdrs, &objp->f))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->w))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->x))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->y))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->z))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCchanneldesc (XDR *xdrs, RCchanneldesc *objp)
{
	register int32_t *buf;

	 if (!xdr_RCchanneldesc_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCtexture_t (XDR *xdrs, RCtexture_t *objp)
{
	register int32_t *buf;

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, (2 + ( 3 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->normalized))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->filterMode))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->addressMode, 3,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->normalized);
		IXDR_PUT_LONG(buf, objp->filterMode);
		{
			register int *genp;

			for (i = 0, genp = objp->addressMode;
				i < 3; ++i) {
				IXDR_PUT_LONG(buf, *genp++);
			}
		}
		}
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
		} else {
			IXDR_PUT_LONG(buf, objp->w);
			IXDR_PUT_LONG(buf, objp->x);
			IXDR_PUT_LONG(buf, objp->y);
			IXDR_PUT_LONG(buf, objp->z);
		}
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, (2 + ( 3 )) * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->normalized))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->filterMode))
				 return FALSE;
			 if (!xdr_vector (xdrs, (char *)objp->addressMode, 3,
				sizeof (int), (xdrproc_t) xdr_int))
				 return FALSE;

		} else {
		objp->normalized = IXDR_GET_LONG(buf);
		objp->filterMode = IXDR_GET_LONG(buf);
		{
			register int *genp;

			for (i = 0, genp = objp->addressMode;
				i < 3; ++i) {
				*genp++ = IXDR_GET_LONG(buf);
			}
		}
		}
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
		} else {
			objp->w = IXDR_GET_LONG(buf);
			objp->x = IXDR_GET_LONG(buf);
			objp->y = IXDR_GET_LONG(buf);
			objp->z = IXDR_GET_LONG(buf);
		}
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->normalized))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->filterMode))
		 return FALSE;
	 if (!xdr_vector (xdrs, (char *)objp->addressMode, 3,
		sizeof (int), (xdrproc_t) xdr_int))
		 return FALSE;
	 if (!xdr_RCchannelformat (xdrs, &objp->f))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->w))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->x))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->y))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->z))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCtexture (XDR *xdrs, RCtexture *objp)
{
	register int32_t *buf;

	 if (!xdr_RCtexture_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCfuncattr_t (XDR *xdrs, RCfuncattr_t *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_int (xdrs, &objp->binaryVersion))
			 return FALSE;
		 if (!xdr_RCsize (xdrs, &objp->constSizeBytes))
			 return FALSE;
		 if (!xdr_RCsize (xdrs, &objp->localSizeBytes))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->maxThreadsPerBlock))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->numRegs))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->ptxVersion))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->maxThreadsPerBlock);
		IXDR_PUT_LONG(buf, objp->numRegs);
		IXDR_PUT_LONG(buf, objp->ptxVersion);
		}
		 if (!xdr_RCsize (xdrs, &objp->sharedSizeBytes))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_int (xdrs, &objp->binaryVersion))
			 return FALSE;
		 if (!xdr_RCsize (xdrs, &objp->constSizeBytes))
			 return FALSE;
		 if (!xdr_RCsize (xdrs, &objp->localSizeBytes))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 3 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->maxThreadsPerBlock))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->numRegs))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->ptxVersion))
				 return FALSE;

		} else {
		objp->maxThreadsPerBlock = IXDR_GET_LONG(buf);
		objp->numRegs = IXDR_GET_LONG(buf);
		objp->ptxVersion = IXDR_GET_LONG(buf);
		}
		 if (!xdr_RCsize (xdrs, &objp->sharedSizeBytes))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->binaryVersion))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->constSizeBytes))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->localSizeBytes))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->maxThreadsPerBlock))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->numRegs))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ptxVersion))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->sharedSizeBytes))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCfuncattr (XDR *xdrs, RCfuncattr *objp)
{
	register int32_t *buf;

	 if (!xdr_RCfuncattr_t (xdrs, objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCargType (XDR *xdrs, RCargType *objp)
{
	register int32_t *buf;

	 if (!xdr_enum (xdrs, (enum_t *) objp))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCargVal (XDR *xdrs, RCargVal *objp)
{
	register int32_t *buf;

	 if (!xdr_RCargType (xdrs, &objp->type))
		 return FALSE;
	switch (objp->type) {
	case dscudaArgTypeP:
		 if (!xdr_RCadr (xdrs, &objp->RCargVal_u.address))
			 return FALSE;
		break;
	case dscudaArgTypeI:
		 if (!xdr_u_int (xdrs, &objp->RCargVal_u.valuei))
			 return FALSE;
		break;
	case dscudaArgTypeF:
		 if (!xdr_float (xdrs, &objp->RCargVal_u.valuef))
			 return FALSE;
		break;
	case dscudaArgTypeV:
		 if (!xdr_vector (xdrs, (char *)objp->RCargVal_u.valuev, 64,
			sizeof (char), (xdrproc_t) xdr_char))
			 return FALSE;
		break;
	default:
		break;
	}
	return TRUE;
}

bool_t
xdr_RCarg (XDR *xdrs, RCarg *objp)
{
	register int32_t *buf;

	 if (!xdr_RCargVal (xdrs, &objp->val))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->size))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCargs (XDR *xdrs, RCargs *objp)
{
	register int32_t *buf;

	 if (!xdr_array (xdrs, (char **)&objp->RCargs_val, (u_int *) &objp->RCargs_len, ~0,
		sizeof (RCarg), (xdrproc_t) xdr_RCarg))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaResult (XDR *xdrs, dscudaResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaThreadGetLimitResult (XDR *xdrs, dscudaThreadGetLimitResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaThreadGetCacheConfigResult (XDR *xdrs, dscudaThreadGetCacheConfigResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->cacheConfig))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMallocResult (XDR *xdrs, dscudaMallocResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->devAdr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaHostAllocResult (XDR *xdrs, dscudaHostAllocResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->pHost))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMallocHostResult (XDR *xdrs, dscudaMallocHostResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->ptr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMallocArrayResult (XDR *xdrs, dscudaMallocArrayResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->array))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMallocPitchResult (XDR *xdrs, dscudaMallocPitchResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->devPtr))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->pitch))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyD2HResult (XDR *xdrs, dscudaMemcpyD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyH2HResult (XDR *xdrs, dscudaMemcpyH2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyToArrayD2HResult (XDR *xdrs, dscudaMemcpyToArrayD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyToArrayH2HResult (XDR *xdrs, dscudaMemcpyToArrayH2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpy2DToArrayD2HResult (XDR *xdrs, dscudaMemcpy2DToArrayD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpy2DToArrayH2HResult (XDR *xdrs, dscudaMemcpy2DToArrayH2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpy2DD2HResult (XDR *xdrs, dscudaMemcpy2DD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpy2DH2HResult (XDR *xdrs, dscudaMemcpy2DH2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaGetDeviceResult (XDR *xdrs, dscudaGetDeviceResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->device))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaGetDeviceCountResult (XDR *xdrs, dscudaGetDeviceCountResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaGetDevicePropertiesResult (XDR *xdrs, dscudaGetDevicePropertiesResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->prop))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaDriverGetVersionResult (XDR *xdrs, dscudaDriverGetVersionResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ver))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaRuntimeGetVersionResult (XDR *xdrs, dscudaRuntimeGetVersionResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ver))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaGetErrorStringResult (XDR *xdrs, dscudaGetErrorStringResult *objp)
{
	register int32_t *buf;

	 if (!xdr_string (xdrs, &objp->errmsg, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaCreateChannelDescResult (XDR *xdrs, dscudaCreateChannelDescResult *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->x);
		IXDR_PUT_LONG(buf, objp->y);
		IXDR_PUT_LONG(buf, objp->z);
		IXDR_PUT_LONG(buf, objp->w);
		}
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;

		} else {
		objp->x = IXDR_GET_LONG(buf);
		objp->y = IXDR_GET_LONG(buf);
		objp->z = IXDR_GET_LONG(buf);
		objp->w = IXDR_GET_LONG(buf);
		}
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_int (xdrs, &objp->x))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->y))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->z))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->w))
		 return FALSE;
	 if (!xdr_RCchannelformat (xdrs, &objp->f))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaGetChannelDescResult (XDR *xdrs, dscudaGetChannelDescResult *objp)
{
	register int32_t *buf;


	if (xdrs->x_op == XDR_ENCODE) {
		 if (!xdr_RCerror (xdrs, &objp->err))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;

		} else {
		IXDR_PUT_LONG(buf, objp->x);
		IXDR_PUT_LONG(buf, objp->y);
		IXDR_PUT_LONG(buf, objp->z);
		IXDR_PUT_LONG(buf, objp->w);
		}
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
		return TRUE;
	} else if (xdrs->x_op == XDR_DECODE) {
		 if (!xdr_RCerror (xdrs, &objp->err))
			 return FALSE;
		buf = XDR_INLINE (xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			 if (!xdr_int (xdrs, &objp->x))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->y))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->z))
				 return FALSE;
			 if (!xdr_int (xdrs, &objp->w))
				 return FALSE;

		} else {
		objp->x = IXDR_GET_LONG(buf);
		objp->y = IXDR_GET_LONG(buf);
		objp->z = IXDR_GET_LONG(buf);
		objp->w = IXDR_GET_LONG(buf);
		}
		 if (!xdr_RCchannelformat (xdrs, &objp->f))
			 return FALSE;
	 return TRUE;
	}

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->x))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->y))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->z))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->w))
		 return FALSE;
	 if (!xdr_RCchannelformat (xdrs, &objp->f))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaChooseDeviceResult (XDR *xdrs, dscudaChooseDeviceResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->device))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyAsyncD2HResult (XDR *xdrs, dscudaMemcpyAsyncD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyAsyncH2HResult (XDR *xdrs, dscudaMemcpyAsyncH2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyFromSymbolD2HResult (XDR *xdrs, dscudaMemcpyFromSymbolD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaMemcpyFromSymbolAsyncD2HResult (XDR *xdrs, dscudaMemcpyFromSymbolAsyncD2HResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->buf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaStreamCreateResult (XDR *xdrs, dscudaStreamCreateResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaEventCreateResult (XDR *xdrs, dscudaEventCreateResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->event))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaEventElapsedTimeResult (XDR *xdrs, dscudaEventElapsedTimeResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_float (xdrs, &objp->ms))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaHostGetDevicePointerResult (XDR *xdrs, dscudaHostGetDevicePointerResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->pDevice))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaHostGetFlagsResult (XDR *xdrs, dscudaHostGetFlagsResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaLoadModuleResult (XDR *xdrs, dscudaLoadModuleResult *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->id))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaFuncGetAttributesResult (XDR *xdrs, dscudaFuncGetAttributesResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCfuncattr (xdrs, &objp->attr))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaBindTextureResult (XDR *xdrs, dscudaBindTextureResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaBindTexture2DResult (XDR *xdrs, dscudaBindTexture2DResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscufftResult (XDR *xdrs, dscufftResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscufftPlanResult (XDR *xdrs, dscufftPlanResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->plan))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscublasResult (XDR *xdrs, dscublasResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->stat))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscublasCreateResult (XDR *xdrs, dscublasCreateResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->stat))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->handle))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscublasGetVectorResult (XDR *xdrs, dscublasGetVectorResult *objp)
{
	register int32_t *buf;

	 if (!xdr_RCerror (xdrs, &objp->err))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->stat))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->y))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_RCdim3 (XDR *xdrs, RCdim3 *objp)
{
	register int32_t *buf;

	 if (!xdr_u_int (xdrs, &objp->x))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->y))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->z))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudathreadsetlimitid_1_argument (XDR *xdrs, dscudathreadsetlimitid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->limit))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->value))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudastreamwaiteventid_1_argument (XDR *xdrs, dscudastreamwaiteventid_1_argument *objp)
{
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	 if (!xdr_RCevent (xdrs, &objp->event))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaeventelapsedtimeid_1_argument (XDR *xdrs, dscudaeventelapsedtimeid_1_argument *objp)
{
	 if (!xdr_RCevent (xdrs, &objp->start))
		 return FALSE;
	 if (!xdr_RCevent (xdrs, &objp->end))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaeventrecordid_1_argument (XDR *xdrs, dscudaeventrecordid_1_argument *objp)
{
	 if (!xdr_RCevent (xdrs, &objp->event))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudalaunchkernelid_1_argument (XDR *xdrs, dscudalaunchkernelid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->kid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->kname, ~0))
		 return FALSE;
	 if (!xdr_RCdim3 (xdrs, &objp->gdim))
		 return FALSE;
	 if (!xdr_RCdim3 (xdrs, &objp->bdim))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->smemsize))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	 if (!xdr_RCargs (xdrs, &objp->args))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudaloadmoduleid_1_argument (XDR *xdrs, dscudaloadmoduleid_1_argument *objp)
{
	 if (!xdr_RCipaddr (xdrs, &objp->ipaddr))
		 return FALSE;
	 if (!xdr_RCpid (xdrs, &objp->pid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->mname, ~0))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->image, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudafuncgetattributesid_1_argument (XDR *xdrs, dscudafuncgetattributesid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->kname, ~0))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyh2hid_1_argument (XDR *xdrs, dscudamemcpyh2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyh2did_1_argument (XDR *xdrs, dscudamemcpyh2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyd2hid_1_argument (XDR *xdrs, dscudamemcpyd2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyd2did_1_argument (XDR *xdrs, dscudamemcpyd2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyasynch2hid_1_argument (XDR *xdrs, dscudamemcpyasynch2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyasynch2did_1_argument (XDR *xdrs, dscudamemcpyasynch2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyasyncd2hid_1_argument (XDR *xdrs, dscudamemcpyasyncd2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyasyncd2did_1_argument (XDR *xdrs, dscudamemcpyasyncd2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytosymbolh2did_1_argument (XDR *xdrs, dscudamemcpytosymbolh2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytosymbold2did_1_argument (XDR *xdrs, dscudamemcpytosymbold2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyfromsymbold2hid_1_argument (XDR *xdrs, dscudamemcpyfromsymbold2hid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyfromsymbold2did_1_argument (XDR *xdrs, dscudamemcpyfromsymbold2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemsetid_1_argument (XDR *xdrs, dscudamemsetid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudahostallocid_1_argument (XDR *xdrs, dscudahostallocid_1_argument *objp)
{
	 if (!xdr_RCsize (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudahostgetdevicepointerid_1_argument (XDR *xdrs, dscudahostgetdevicepointerid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->pHost))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamallocarrayid_1_argument (XDR *xdrs, dscudamallocarrayid_1_argument *objp)
{
	 if (!xdr_RCchanneldesc (xdrs, &objp->desc))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->flags))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytoarrayh2hid_1_argument (XDR *xdrs, dscudamemcpytoarrayh2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytoarrayh2did_1_argument (XDR *xdrs, dscudamemcpytoarrayh2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytoarrayd2hid_1_argument (XDR *xdrs, dscudamemcpytoarrayd2hid_1_argument *objp)
{
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytoarrayd2did_1_argument (XDR *xdrs, dscudamemcpytoarrayd2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamallocpitchid_1_argument (XDR *xdrs, dscudamallocpitchid_1_argument *objp)
{
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dtoarrayh2hid_1_argument (XDR *xdrs, dscudamemcpy2dtoarrayh2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dtoarrayh2did_1_argument (XDR *xdrs, dscudamemcpy2dtoarrayh2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->srcbuf))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dtoarrayd2hid_1_argument (XDR *xdrs, dscudamemcpy2dtoarrayd2hid_1_argument *objp)
{
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dtoarrayd2did_1_argument (XDR *xdrs, dscudamemcpy2dtoarrayd2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->wOffset))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->hOffset))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dh2hid_1_argument (XDR *xdrs, dscudamemcpy2dh2hid_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->dpitch))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dh2did_1_argument (XDR *xdrs, dscudamemcpy2dh2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->dpitch))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dd2hid_1_argument (XDR *xdrs, dscudamemcpy2dd2hid_1_argument *objp)
{
	 if (!xdr_RCsize (xdrs, &objp->dpitch))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpy2dd2did_1_argument (XDR *xdrs, dscudamemcpy2dd2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->dpitch))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->spitch))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemset2did_1_argument (XDR *xdrs, dscudamemset2did_1_argument *objp)
{
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->pitch))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->value))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytosymbolasynch2did_1_argument (XDR *xdrs, dscudamemcpytosymbolasynch2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCbuf (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpytosymbolasyncd2did_1_argument (XDR *xdrs, dscudamemcpytosymbolasyncd2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->src))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyfromsymbolasyncd2hid_1_argument (XDR *xdrs, dscudamemcpyfromsymbolasyncd2hid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudamemcpyfromsymbolasyncd2did_1_argument (XDR *xdrs, dscudamemcpyfromsymbolasyncd2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->dst))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->symbol, ~0))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->count))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->offset))
		 return FALSE;
	 if (!xdr_RCstream (xdrs, &objp->stream))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudacreatechanneldescid_1_argument (XDR *xdrs, dscudacreatechanneldescid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->x))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->y))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->z))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->w))
		 return FALSE;
	 if (!xdr_RCchannelformat (xdrs, &objp->f))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudabindtextureid_1_argument (XDR *xdrs, dscudabindtextureid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->texname, ~0))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->devPtr))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->size))
		 return FALSE;
	 if (!xdr_RCtexture (xdrs, &objp->texbuf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudabindtexture2did_1_argument (XDR *xdrs, dscudabindtexture2did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->texname, ~0))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->devPtr))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->width))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->height))
		 return FALSE;
	 if (!xdr_RCsize (xdrs, &objp->pitch))
		 return FALSE;
	 if (!xdr_RCtexture (xdrs, &objp->texbuf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscudabindtexturetoarrayid_1_argument (XDR *xdrs, dscudabindtexturetoarrayid_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->moduleid))
		 return FALSE;
	 if (!xdr_string (xdrs, &objp->texname, ~0))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->array))
		 return FALSE;
	 if (!xdr_RCtexture (xdrs, &objp->texbuf))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscufftplan3did_1_argument (XDR *xdrs, dscufftplan3did_1_argument *objp)
{
	 if (!xdr_int (xdrs, &objp->nx))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->ny))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->nz))
		 return FALSE;
	 if (!xdr_u_int (xdrs, &objp->type))
		 return FALSE;
	return TRUE;
}

bool_t
xdr_dscufftexecc2cid_1_argument (XDR *xdrs, dscufftexecc2cid_1_argument *objp)
{
	 if (!xdr_u_int (xdrs, &objp->plan))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->idata))
		 return FALSE;
	 if (!xdr_RCadr (xdrs, &objp->odata))
		 return FALSE;
	 if (!xdr_int (xdrs, &objp->direction))
		 return FALSE;
	return TRUE;
}
