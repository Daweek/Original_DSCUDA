/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "dscudarpc.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

dscudaResult *
dscudathreadexitid_1(CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaThreadExitId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudathreadsynchronizeid_1(CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaThreadSynchronizeId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudathreadsetlimitid_1(int limit, RCsize value,  CLIENT *clnt)
{
	dscudathreadsetlimitid_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.limit = limit;
	arg.value = value;
	if (clnt_call (clnt, dscudaThreadSetLimitId, (xdrproc_t) xdr_dscudathreadsetlimitid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaThreadGetLimitResult *
dscudathreadgetlimitid_1(int limit,  CLIENT *clnt)
{
	static dscudaThreadGetLimitResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaThreadGetLimitId,
		(xdrproc_t) xdr_int, (caddr_t) &limit,
		(xdrproc_t) xdr_dscudaThreadGetLimitResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudathreadsetcacheconfigid_1(int chacheConfig,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaThreadSetCacheConfigId,
		(xdrproc_t) xdr_int, (caddr_t) &chacheConfig,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaThreadGetCacheConfigResult *
dscudathreadgetcacheconfigid_1(CLIENT *clnt)
{
	static dscudaThreadGetCacheConfigResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaThreadGetCacheConfigId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaThreadGetCacheConfigResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudagetlasterrorid_1(CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaGetLastErrorId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudapeekatlasterrorid_1(CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaPeekAtLastErrorId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaGetErrorStringResult *
dscudageterrorstringid_1(int err,  CLIENT *clnt)
{
	static dscudaGetErrorStringResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaGetErrorStringId,
		(xdrproc_t) xdr_int, (caddr_t) &err,
		(xdrproc_t) xdr_dscudaGetErrorStringResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaGetDeviceResult *
dscudagetdeviceid_1(CLIENT *clnt)
{
	static dscudaGetDeviceResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaGetDeviceId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaGetDeviceResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaGetDeviceCountResult *
dscudagetdevicecountid_1(CLIENT *clnt)
{
	static dscudaGetDeviceCountResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaGetDeviceCountId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaGetDeviceCountResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaGetDevicePropertiesResult *
dscudagetdevicepropertiesid_1(int device,  CLIENT *clnt)
{
	static dscudaGetDevicePropertiesResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaGetDevicePropertiesId,
		(xdrproc_t) xdr_int, (caddr_t) &device,
		(xdrproc_t) xdr_dscudaGetDevicePropertiesResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaDriverGetVersionResult *
dscudadrivergetversionid_1(CLIENT *clnt)
{
	static dscudaDriverGetVersionResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaDriverGetVersionId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaDriverGetVersionResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaRuntimeGetVersionResult *
dscudaruntimegetversionid_1(CLIENT *clnt)
{
	static dscudaRuntimeGetVersionResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaRuntimeGetVersionId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaRuntimeGetVersionResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudasetdeviceid_1(int device,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaSetDeviceId,
		(xdrproc_t) xdr_int, (caddr_t) &device,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudasetdeviceflagsid_1(u_int flags,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaSetDeviceFlagsId,
		(xdrproc_t) xdr_u_int, (caddr_t) &flags,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaChooseDeviceResult *
dscudachoosedeviceid_1(RCbuf prop,  CLIENT *clnt)
{
	static dscudaChooseDeviceResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaChooseDeviceId,
		(xdrproc_t) xdr_RCbuf, (caddr_t) &prop,
		(xdrproc_t) xdr_dscudaChooseDeviceResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudadevicesynchronize_1(CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaDeviceSynchronize, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudadevicereset_1(CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaDeviceReset, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaStreamCreateResult *
dscudastreamcreateid_1(CLIENT *clnt)
{
	static dscudaStreamCreateResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaStreamCreateId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaStreamCreateResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudastreamdestroyid_1(RCstream stream,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaStreamDestroyId,
		(xdrproc_t) xdr_RCstream, (caddr_t) &stream,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudastreamsynchronizeid_1(RCstream stream,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaStreamSynchronizeId,
		(xdrproc_t) xdr_RCstream, (caddr_t) &stream,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudastreamqueryid_1(RCstream stream,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaStreamQueryId,
		(xdrproc_t) xdr_RCstream, (caddr_t) &stream,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudastreamwaiteventid_1(RCstream stream, RCevent event, u_int flags,  CLIENT *clnt)
{
	dscudastreamwaiteventid_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.stream = stream;
	arg.event = event;
	arg.flags = flags;
	if (clnt_call (clnt, dscudaStreamWaitEventId, (xdrproc_t) xdr_dscudastreamwaiteventid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaEventCreateResult *
dscudaeventcreateid_1(CLIENT *clnt)
{
	static dscudaEventCreateResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	 if (clnt_call (clnt, dscudaEventCreateId, (xdrproc_t) xdr_void, (caddr_t) NULL,
		(xdrproc_t) xdr_dscudaEventCreateResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaEventCreateResult *
dscudaeventcreatewithflagsid_1(u_int flags,  CLIENT *clnt)
{
	static dscudaEventCreateResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaEventCreateWithFlagsId,
		(xdrproc_t) xdr_u_int, (caddr_t) &flags,
		(xdrproc_t) xdr_dscudaEventCreateResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudaeventdestroyid_1(RCevent event,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaEventDestroyId,
		(xdrproc_t) xdr_RCevent, (caddr_t) &event,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaEventElapsedTimeResult *
dscudaeventelapsedtimeid_1(RCevent start, RCevent end,  CLIENT *clnt)
{
	dscudaeventelapsedtimeid_1_argument arg;
	static dscudaEventElapsedTimeResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.start = start;
	arg.end = end;
	if (clnt_call (clnt, dscudaEventElapsedTimeId, (xdrproc_t) xdr_dscudaeventelapsedtimeid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaEventElapsedTimeResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudaeventrecordid_1(RCevent event, RCstream stream,  CLIENT *clnt)
{
	dscudaeventrecordid_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.event = event;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaEventRecordId, (xdrproc_t) xdr_dscudaeventrecordid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudaeventsynchronizeid_1(RCevent event,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaEventSynchronizeId,
		(xdrproc_t) xdr_RCevent, (caddr_t) &event,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudaeventqueryid_1(RCevent event,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaEventQueryId,
		(xdrproc_t) xdr_RCevent, (caddr_t) &event,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
dscudalaunchkernelid_1(int moduleid, int kid, char *kname, RCdim3 gdim, RCdim3 bdim, RCsize smemsize, RCstream stream, RCargs args,  CLIENT *clnt)
{
	dscudalaunchkernelid_1_argument arg;
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.kid = kid;
	arg.kname = kname;
	arg.gdim = gdim;
	arg.bdim = bdim;
	arg.smemsize = smemsize;
	arg.stream = stream;
	arg.args = args;
	if (clnt_call (clnt, dscudaLaunchKernelId, (xdrproc_t) xdr_dscudalaunchkernelid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

dscudaLoadModuleResult *
dscudaloadmoduleid_1(RCipaddr ipaddr, RCpid pid, char *mname, char *image,  CLIENT *clnt)
{
	dscudaloadmoduleid_1_argument arg;
	static dscudaLoadModuleResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.ipaddr = ipaddr;
	arg.pid = pid;
	arg.mname = mname;
	arg.image = image;
	if (clnt_call (clnt, dscudaLoadModuleId, (xdrproc_t) xdr_dscudaloadmoduleid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaLoadModuleResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaFuncGetAttributesResult *
dscudafuncgetattributesid_1(int moduleid, char *kname,  CLIENT *clnt)
{
	dscudafuncgetattributesid_1_argument arg;
	static dscudaFuncGetAttributesResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.kname = kname;
	if (clnt_call (clnt, dscudaFuncGetAttributesId, (xdrproc_t) xdr_dscudafuncgetattributesid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaFuncGetAttributesResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMallocResult *
dscudamallocid_1(RCsize size,  CLIENT *clnt)
{
	static dscudaMallocResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaMallocId,
		(xdrproc_t) xdr_RCsize, (caddr_t) &size,
		(xdrproc_t) xdr_dscudaMallocResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudafreeid_1(RCadr mem,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaFreeId,
		(xdrproc_t) xdr_RCadr, (caddr_t) &mem,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyH2HResult *
dscudamemcpyh2hid_1(RCadr dst, RCbuf src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpyh2hid_1_argument arg;
	static dscudaMemcpyH2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyH2HId, (xdrproc_t) xdr_dscudamemcpyh2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyH2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpyh2did_1(RCadr dst, RCbuf src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpyh2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyH2DId, (xdrproc_t) xdr_dscudamemcpyh2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyD2HResult *
dscudamemcpyd2hid_1(RCadr src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpyd2hid_1_argument arg;
	static dscudaMemcpyD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyD2HId, (xdrproc_t) xdr_dscudamemcpyd2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpyd2did_1(RCadr dst, RCadr src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpyd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyD2DId, (xdrproc_t) xdr_dscudamemcpyd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyAsyncH2HResult *
dscudamemcpyasynch2hid_1(RCadr dst, RCbuf src, RCsize count, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpyasynch2hid_1_argument arg;
	static dscudaMemcpyAsyncH2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.src = src;
	arg.count = count;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyAsyncH2HId, (xdrproc_t) xdr_dscudamemcpyasynch2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyAsyncH2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpyasynch2did_1(RCadr dst, RCbuf src, RCsize count, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpyasynch2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.src = src;
	arg.count = count;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyAsyncH2DId, (xdrproc_t) xdr_dscudamemcpyasynch2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyAsyncD2HResult *
dscudamemcpyasyncd2hid_1(RCadr src, RCsize count, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpyasyncd2hid_1_argument arg;
	static dscudaMemcpyAsyncD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.src = src;
	arg.count = count;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyAsyncD2HId, (xdrproc_t) xdr_dscudamemcpyasyncd2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyAsyncD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpyasyncd2did_1(RCadr dst, RCadr src, RCsize count, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpyasyncd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.src = src;
	arg.count = count;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyAsyncD2DId, (xdrproc_t) xdr_dscudamemcpyasyncd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpytosymbolh2did_1(int moduleid, char *symbol, RCbuf src, RCsize count, RCsize offset,  CLIENT *clnt)
{
	dscudamemcpytosymbolh2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.symbol = symbol;
	arg.src = src;
	arg.count = count;
	arg.offset = offset;
	if (clnt_call (clnt, dscudaMemcpyToSymbolH2DId, (xdrproc_t) xdr_dscudamemcpytosymbolh2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpytosymbold2did_1(int moduleid, char *symbol, RCadr src, RCsize count, RCsize offset,  CLIENT *clnt)
{
	dscudamemcpytosymbold2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.symbol = symbol;
	arg.src = src;
	arg.count = count;
	arg.offset = offset;
	if (clnt_call (clnt, dscudaMemcpyToSymbolD2DId, (xdrproc_t) xdr_dscudamemcpytosymbold2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyFromSymbolD2HResult *
dscudamemcpyfromsymbold2hid_1(int moduleid, char *symbol, RCsize count, RCsize offset,  CLIENT *clnt)
{
	dscudamemcpyfromsymbold2hid_1_argument arg;
	static dscudaMemcpyFromSymbolD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.symbol = symbol;
	arg.count = count;
	arg.offset = offset;
	if (clnt_call (clnt, dscudaMemcpyFromSymbolD2HId, (xdrproc_t) xdr_dscudamemcpyfromsymbold2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyFromSymbolD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpyfromsymbold2did_1(int moduleid, RCadr dst, char *symbol, RCsize count, RCsize offset,  CLIENT *clnt)
{
	dscudamemcpyfromsymbold2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.dst = dst;
	arg.symbol = symbol;
	arg.count = count;
	arg.offset = offset;
	if (clnt_call (clnt, dscudaMemcpyFromSymbolD2DId, (xdrproc_t) xdr_dscudamemcpyfromsymbold2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemsetid_1(RCadr dst, int value, RCsize count,  CLIENT *clnt)
{
	dscudamemsetid_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.value = value;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemsetId, (xdrproc_t) xdr_dscudamemsetid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaHostAllocResult *
dscudahostallocid_1(RCsize size, u_int flags,  CLIENT *clnt)
{
	dscudahostallocid_1_argument arg;
	static dscudaHostAllocResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.size = size;
	arg.flags = flags;
	if (clnt_call (clnt, dscudaHostAllocId, (xdrproc_t) xdr_dscudahostallocid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaHostAllocResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMallocHostResult *
dscudamallochostid_1(RCsize size,  CLIENT *clnt)
{
	static dscudaMallocHostResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaMallocHostId,
		(xdrproc_t) xdr_RCsize, (caddr_t) &size,
		(xdrproc_t) xdr_dscudaMallocHostResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudafreehostid_1(RCadr ptr,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaFreeHostId,
		(xdrproc_t) xdr_RCadr, (caddr_t) &ptr,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaHostGetDevicePointerResult *
dscudahostgetdevicepointerid_1(RCadr pHost, u_int flags,  CLIENT *clnt)
{
	dscudahostgetdevicepointerid_1_argument arg;
	static dscudaHostGetDevicePointerResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.pHost = pHost;
	arg.flags = flags;
	if (clnt_call (clnt, dscudaHostGetDevicePointerId, (xdrproc_t) xdr_dscudahostgetdevicepointerid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaHostGetDevicePointerResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaHostGetFlagsResult *
dscudahostgetflagsid_1(RCadr pHost,  CLIENT *clnt)
{
	static dscudaHostGetFlagsResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaHostGetFlagsID,
		(xdrproc_t) xdr_RCadr, (caddr_t) &pHost,
		(xdrproc_t) xdr_dscudaHostGetFlagsResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMallocArrayResult *
dscudamallocarrayid_1(RCchanneldesc desc, RCsize width, RCsize height, u_int flags,  CLIENT *clnt)
{
	dscudamallocarrayid_1_argument arg;
	static dscudaMallocArrayResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.desc = desc;
	arg.width = width;
	arg.height = height;
	arg.flags = flags;
	if (clnt_call (clnt, dscudaMallocArrayId, (xdrproc_t) xdr_dscudamallocarrayid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMallocArrayResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudafreearrayid_1(RCadr array,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaFreeArrayId,
		(xdrproc_t) xdr_RCadr, (caddr_t) &array,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyToArrayH2HResult *
dscudamemcpytoarrayh2hid_1(RCadr dst, RCsize wOffset, RCsize hOffset, RCbuf src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpytoarrayh2hid_1_argument arg;
	static dscudaMemcpyToArrayH2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyToArrayH2HId, (xdrproc_t) xdr_dscudamemcpytoarrayh2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyToArrayH2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpytoarrayh2did_1(RCadr dst, RCsize wOffset, RCsize hOffset, RCbuf src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpytoarrayh2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyToArrayH2DId, (xdrproc_t) xdr_dscudamemcpytoarrayh2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyToArrayD2HResult *
dscudamemcpytoarrayd2hid_1(RCsize wOffset, RCsize hOffset, RCadr src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpytoarrayd2hid_1_argument arg;
	static dscudaMemcpyToArrayD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyToArrayD2HId, (xdrproc_t) xdr_dscudamemcpytoarrayd2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyToArrayD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpytoarrayd2did_1(RCadr dst, RCsize wOffset, RCsize hOffset, RCadr src, RCsize count,  CLIENT *clnt)
{
	dscudamemcpytoarrayd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.count = count;
	if (clnt_call (clnt, dscudaMemcpyToArrayD2DId, (xdrproc_t) xdr_dscudamemcpytoarrayd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMallocPitchResult *
dscudamallocpitchid_1(RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamallocpitchid_1_argument arg;
	static dscudaMallocPitchResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMallocPitchId, (xdrproc_t) xdr_dscudamallocpitchid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMallocPitchResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpy2DToArrayH2HResult *
dscudamemcpy2dtoarrayh2hid_1(RCadr dst, RCsize wOffset, RCsize hOffset, RCbuf src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dtoarrayh2hid_1_argument arg;
	static dscudaMemcpy2DToArrayH2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DToArrayH2HId, (xdrproc_t) xdr_dscudamemcpy2dtoarrayh2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpy2DToArrayH2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpy2dtoarrayh2did_1(RCadr dst, RCsize wOffset, RCsize hOffset, RCbuf srcbuf, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dtoarrayh2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.srcbuf = srcbuf;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DToArrayH2DId, (xdrproc_t) xdr_dscudamemcpy2dtoarrayh2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpy2DToArrayD2HResult *
dscudamemcpy2dtoarrayd2hid_1(RCsize wOffset, RCsize hOffset, RCadr src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dtoarrayd2hid_1_argument arg;
	static dscudaMemcpy2DToArrayD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DToArrayD2HId, (xdrproc_t) xdr_dscudamemcpy2dtoarrayd2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpy2DToArrayD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpy2dtoarrayd2did_1(RCadr dst, RCsize wOffset, RCsize hOffset, RCadr src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dtoarrayd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.wOffset = wOffset;
	arg.hOffset = hOffset;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DToArrayD2DId, (xdrproc_t) xdr_dscudamemcpy2dtoarrayd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpy2DH2HResult *
dscudamemcpy2dh2hid_1(RCadr dst, RCsize dpitch, RCbuf src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dh2hid_1_argument arg;
	static dscudaMemcpy2DH2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.dpitch = dpitch;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DH2HId, (xdrproc_t) xdr_dscudamemcpy2dh2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpy2DH2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpy2dh2did_1(RCadr dst, RCsize dpitch, RCbuf src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dh2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.dpitch = dpitch;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DH2DId, (xdrproc_t) xdr_dscudamemcpy2dh2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpy2DD2HResult *
dscudamemcpy2dd2hid_1(RCsize dpitch, RCadr src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dd2hid_1_argument arg;
	static dscudaMemcpy2DD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dpitch = dpitch;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DD2HId, (xdrproc_t) xdr_dscudamemcpy2dd2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpy2DD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpy2dd2did_1(RCadr dst, RCsize dpitch, RCadr src, RCsize spitch, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemcpy2dd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.dpitch = dpitch;
	arg.src = src;
	arg.spitch = spitch;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemcpy2DD2DId, (xdrproc_t) xdr_dscudamemcpy2dd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemset2did_1(RCadr dst, RCsize pitch, int value, RCsize width, RCsize height,  CLIENT *clnt)
{
	dscudamemset2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.dst = dst;
	arg.pitch = pitch;
	arg.value = value;
	arg.width = width;
	arg.height = height;
	if (clnt_call (clnt, dscudaMemset2DId, (xdrproc_t) xdr_dscudamemset2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpytosymbolasynch2did_1(int moduleid, char *symbol, RCbuf src, RCsize count, RCsize offset, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpytosymbolasynch2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.symbol = symbol;
	arg.src = src;
	arg.count = count;
	arg.offset = offset;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyToSymbolAsyncH2DId, (xdrproc_t) xdr_dscudamemcpytosymbolasynch2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpytosymbolasyncd2did_1(int moduleid, char *symbol, RCadr src, RCsize count, RCsize offset, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpytosymbolasyncd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.symbol = symbol;
	arg.src = src;
	arg.count = count;
	arg.offset = offset;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyToSymbolAsyncD2DId, (xdrproc_t) xdr_dscudamemcpytosymbolasyncd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaMemcpyFromSymbolAsyncD2HResult *
dscudamemcpyfromsymbolasyncd2hid_1(int moduleid, char *symbol, RCsize count, RCsize offset, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpyfromsymbolasyncd2hid_1_argument arg;
	static dscudaMemcpyFromSymbolAsyncD2HResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.symbol = symbol;
	arg.count = count;
	arg.offset = offset;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyFromSymbolAsyncD2HId, (xdrproc_t) xdr_dscudamemcpyfromsymbolasyncd2hid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaMemcpyFromSymbolAsyncD2HResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudamemcpyfromsymbolasyncd2did_1(int moduleid, RCadr dst, char *symbol, RCsize count, RCsize offset, RCstream stream,  CLIENT *clnt)
{
	dscudamemcpyfromsymbolasyncd2did_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.dst = dst;
	arg.symbol = symbol;
	arg.count = count;
	arg.offset = offset;
	arg.stream = stream;
	if (clnt_call (clnt, dscudaMemcpyFromSymbolAsyncD2DId, (xdrproc_t) xdr_dscudamemcpyfromsymbolasyncd2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaCreateChannelDescResult *
dscudacreatechanneldescid_1(int x, int y, int z, int w, RCchannelformat f,  CLIENT *clnt)
{
	dscudacreatechanneldescid_1_argument arg;
	static dscudaCreateChannelDescResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.x = x;
	arg.y = y;
	arg.z = z;
	arg.w = w;
	arg.f = f;
	if (clnt_call (clnt, dscudaCreateChannelDescId, (xdrproc_t) xdr_dscudacreatechanneldescid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaCreateChannelDescResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaGetChannelDescResult *
dscudagetchanneldescid_1(RCadr array,  CLIENT *clnt)
{
	static dscudaGetChannelDescResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaGetChannelDescId,
		(xdrproc_t) xdr_RCadr, (caddr_t) &array,
		(xdrproc_t) xdr_dscudaGetChannelDescResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaBindTextureResult *
dscudabindtextureid_1(int moduleid, char *texname, RCadr devPtr, RCsize size, RCtexture texbuf,  CLIENT *clnt)
{
	dscudabindtextureid_1_argument arg;
	static dscudaBindTextureResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.texname = texname;
	arg.devPtr = devPtr;
	arg.size = size;
	arg.texbuf = texbuf;
	if (clnt_call (clnt, dscudaBindTextureId, (xdrproc_t) xdr_dscudabindtextureid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaBindTextureResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaBindTexture2DResult *
dscudabindtexture2did_1(int moduleid, char *texname, RCadr devPtr, RCsize width, RCsize height, RCsize pitch, RCtexture texbuf,  CLIENT *clnt)
{
	dscudabindtexture2did_1_argument arg;
	static dscudaBindTexture2DResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.texname = texname;
	arg.devPtr = devPtr;
	arg.width = width;
	arg.height = height;
	arg.pitch = pitch;
	arg.texbuf = texbuf;
	if (clnt_call (clnt, dscudaBindTexture2DId, (xdrproc_t) xdr_dscudabindtexture2did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaBindTexture2DResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudabindtexturetoarrayid_1(int moduleid, char *texname, RCadr array, RCtexture texbuf,  CLIENT *clnt)
{
	dscudabindtexturetoarrayid_1_argument arg;
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.moduleid = moduleid;
	arg.texname = texname;
	arg.array = array;
	arg.texbuf = texbuf;
	if (clnt_call (clnt, dscudaBindTextureToArrayId, (xdrproc_t) xdr_dscudabindtexturetoarrayid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscudaResult *
dscudaunbindtextureid_1(RCtexture texbuf,  CLIENT *clnt)
{
	static dscudaResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscudaUnbindTextureId,
		(xdrproc_t) xdr_RCtexture, (caddr_t) &texbuf,
		(xdrproc_t) xdr_dscudaResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscufftPlanResult *
dscufftplan3did_1(int nx, int ny, int nz, u_int type,  CLIENT *clnt)
{
	dscufftplan3did_1_argument arg;
	static dscufftPlanResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.nx = nx;
	arg.ny = ny;
	arg.nz = nz;
	arg.type = type;
	if (clnt_call (clnt, dscufftPlan3dId, (xdrproc_t) xdr_dscufftplan3did_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscufftPlanResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscufftResult *
dscufftdestroyid_1(u_int plan,  CLIENT *clnt)
{
	static dscufftResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, dscufftDestroyId,
		(xdrproc_t) xdr_u_int, (caddr_t) &plan,
		(xdrproc_t) xdr_dscufftResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

dscufftResult *
dscufftexecc2cid_1(u_int plan, RCadr idata, RCadr odata, int direction,  CLIENT *clnt)
{
	dscufftexecc2cid_1_argument arg;
	static dscufftResult clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.plan = plan;
	arg.idata = idata;
	arg.odata = odata;
	arg.direction = direction;
	if (clnt_call (clnt, dscufftExecC2CId, (xdrproc_t) xdr_dscufftexecc2cid_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_dscufftResult, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}
